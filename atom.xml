<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-27T01:36:28.125Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>大吉大利小米酱</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年过去了，我很怀念它</title>
    <link href="http://yoursite.com/2019/01/28/2018%E8%BF%87%E5%8E%BB%E4%BA%86%EF%BC%8C%E6%88%91%E5%BE%88%E6%80%80%E5%BF%B5%E5%AE%83/"/>
    <id>http://yoursite.com/2019/01/28/2018过去了，我很怀念它/</id>
    <published>2019-01-28T08:34:00.000Z</published>
    <updated>2019-02-27T01:36:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有更新文章了，一抬头已是2019年了，这一晃从转行至今已经过去1年了，日子过得越来越匆忙，也是时候停下<del>摸鱼的</del>脚步，做个小总结了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/25/168844d12a094ba7?w=54&amp;h=46&amp;f=png&amp;s=5214" alt=""></p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我是<strong>大吉大利小米酱</strong>，如果觉得名字太长，可以叫我小米。</p><p>这和吃鸡一点没有关系，只是希望自己能够大吉大利(手动微笑)。</p><p>一个在众多技术性大佬中靠卖萌求生的小透明。</p><p>是个非科班的烟酒森，18年初入了码农这一行，到最后干着码畜的活(摊手，就这么兜兜转转过去了一年。</p><p>最开始的工作是爬虫，期间没多久就离开了(详见我写的《爬虫劝退文》)，成了一个数据工程师，专注数据开发、数据仓库和数据挖掘。</p><h2 id="立过的flag实现了吗"><a href="#立过的flag实现了吗" class="headerlink" title="立过的flag实现了吗"></a>立过的flag实现了吗</h2><p>先说说和17年比起来，都有了哪些进步：</p><ul><li>在18年底实现了转行前薪资的3倍提升。</li><li>锻炼身体，瘦了10斤</li><li>读了1本闲书(《笑什么笑，我们搞的是科学》安利给喜欢脑洞的朋友们)</li><li>变得乐观了很多</li></ul><p>当然了，也有一大堆没实现的flag：</p><ul><li>18年只写了2篇文章，且都没什么干货</li><li>起手了2、3个项目，但最后都没做完(学习大忌，半途而废！)</li><li>笔记里躺了100多篇工作日记心得，却无一篇总结</li><li>依旧没结婚(这不是目标，这不是目标，over)</li></ul><p>所以18年也算圆满充实又拖拖拉拉的过完了。</p><h2 id="掉过的坑都长记性了吗"><a href="#掉过的坑都长记性了吗" class="headerlink" title="掉过的坑都长记性了吗"></a>掉过的坑都长记性了吗</h2><p>总有关注我的朋友来问我爬虫这一行怎么样，其实不置可否，我更倾向于选择自己热爱的工作，做爬虫是为了接近数据，不做爬虫也是为了更接近数据。</p><p>回想起刚入行时写过的数据分析博客，如今见识了更多的大佬之后，越发觉得自己以前是班门弄斧，想要总结一下好的技术，也还需要更多的沉淀。</p><p>掘金是个技术性很强的社区，所以在这里我就不写技术上的总结了，写写这一年里所感所想吧。</p><h4 id="选择的困顿"><a href="#选择的困顿" class="headerlink" title="选择的困顿"></a>选择的困顿</h4><p>因为以前在知乎写过转行的回答，这一年里总有人私信问我诸如“如何转行”、“如何学习XXX”、“选XXX怎么样”的问题。</p><p>关于这个问题，我觉得作为一个程序员，最基本的技能就是善用搜索引擎，新手会遇到的问题大部分都可以找到。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/25/1688443e75bc4dce?w=268&amp;h=89&amp;f=png&amp;s=7546" alt=""></p><p><strong>按度成仓</strong>：形容百度之后获取的资料能够堆积成仓。(百度：泛指搜索引擎，包括并不限于百度、掘金、CSDN…)</p><p>其实这些也是作为一个程序员最基本的技能，提高搜商，梳理解决问题的关键，踏实学习。</p><p>我知道很多没入门和刚入门的人可能都是迷茫的徘徊在选择与努力的困境中，不知所措，今年的互联网寒冬大家也看到了，希望想要转行的原因是出于热爱而不是单纯因为钱，就算是因为钱也希望不是闭着眼就往里钻。</p><h4 id="坚持的习惯"><a href="#坚持的习惯" class="headerlink" title="坚持的习惯"></a>坚持的习惯</h4><p><strong>1.写日志</strong>：这一年写了近150篇日志笔记，一部分是工作的记录，一部分是一些难倒自己的小细节的复述与思考，还有零星几篇总结。</p><p>记笔记的初衷是因为刚开始接触工作时接收了很多零碎化的知识，无法消化，也无法刻在脑子中，于是都记成了笔记，后来就成了习惯，如今不管大事小事多么忙碌都会记上一笔，权当是流水账。</p><p>写日志带来的好处是，一则遇到一些历史问题很快就可以定位到具体的时间以及当初的处理方式，二则协助了很多同事不再同一个坑里跌倒，三则温故而知新，长久下来，对于工作内容变得可以融会贯通了。</p><p><strong>2.三省吾身</strong>：今年在述职的时候用了SWOT分析模型，SWOT分析法被用于制定集团发展战略和分析竞争对手情况，以个人为分析对象，可以对自己所处的情景进行全面、系统、准确的研究，再根据分析结果采取相应的措施。<br><img src="https://user-gold-cdn.xitu.io/2019/1/25/16884456eccc1024?w=898&amp;h=464&amp;f=png&amp;s=207023" alt=""><br>简单点说就是了解自己的优势与劣势，洞察大环境的局势对自己的正负面影响。这里大环境的局势又需要个人保持对外部环境的警觉性，了解公司发展，随时关注行业动态，国家新闻，世界格局，此处另说。行业动态推荐掘金的chrome插件，设置新标签页默认显示，懒人专用(不收广告费哈哈~)，也可以加几个氛围好的交流群，在闲暇摸鱼的时间里和同行交流。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/25/1688445a9060b020?w=256&amp;h=80&amp;f=png&amp;s=6878" alt=""></p><p><strong>浑水摸鱼</strong>：形容在水群的过程中摸鱼。</p><p><strong>3.不断细化自己的目标(flag)</strong>：对于flag爱好者来说，立flag一时爽，完成flag火……关于解决执行力和拖延症的问题，知乎有大把解决方法，自己搜。这里说的是要逐步细化自己的目标，我有时候是这样的，让我业余学一门语言，我可能没坚持几天就放弃了，但让我点几下鼠标做个问卷我很快就完成了。这里可以参考<a href="http://k.sina.com.cn/article_2469220754_932d519203400383z.html?cre=sportspagepc&amp;mod=f&amp;loc=4&amp;r=9&amp;doct=0&amp;rfunc=100&amp;tj=none" target="_blank" rel="noopener">日本马拉松运动员的故事</a>，分解大目标为一个个小目标。写一篇博客，不知从何写起，那就先列提纲，再不断的拓展。每完成一部分，就离自己的flag更近。</p><p><strong>4.锻炼身体</strong>：是老生常谈的问题了，不过还是需要坚持，身体是革命的本钱，18年太多熟悉的人离开了我们，李咏的英年早逝让人甚是叹惜。程序员这一行负面的新闻每年都很多，所以为了所有关心我们的人，还是需要有一个健康的身体，定期体检，健康饮食，坚持运动。</p><h4 id="长远的思考"><a href="#长远的思考" class="headerlink" title="长远的思考"></a>长远的思考</h4><p><strong>1.广度&amp;维度</strong>：这可能是很多转行者容易犯的错误，杂七杂八学了各种语言，样样都会，样样不精通。虽说狡兔三穴，但也是建立在这三穴已经融会贯通的前提下。</p><p><code>深度带来生存的技能，广度带来生活的乐趣</code>对于还处于初级阶段的吾辈行业菜鸟来说，更需要细心打磨的，是知识的深度，当对于某个领域的知识深入到一定地步，其实知识网络自然而然就变得肥肠(诚实的输入法……)复杂，也会形成思维模式固化，此时拓展知识的广度，不仅是增加新的技能点，更是能获取更多不同的观点，看待问题刁钻的角度。</p><p><strong>2.个人的护城河</strong>：“护城河”这个概念是巴菲特提出来分析公司的核心竞争力的，我觉得人也应该有护城河。</p><p>在工作中，普通人往往做的都是去角色化的工作(俗称搬砖)，企业需要的是一个按时完成岗位工作的员工，你随时可以被替代，所以不断打磨提升自己的技术水平只是职场生存的基本，良好的职业形象和个人素养可以给我们带来更多的认可与机会。</p><p>而打造自己的个人品牌，诸如在互联网时代，构建个人的价值观和思维体系(不是让你做键盘侠)，包括对于行业的思考和市场的趋势分析，写博客，造轮子，角度刁钻的分析，比比皆是。</p><p><strong>3.跳出思维之墙</strong>：有时候，我们在专注技术的时候，容易局限于某一类技术的发展，忽略了产业的兴衰，从18世纪60年代至今，人类社会经历了3次工业革命，经历了蒸汽技术革命，电力技术革命，计算机及信息技术革命，而以人工智能、量子信息技术等全新技术为主的工业4.0也悄然到来。</p><p>我们从曾经的百团大战，O2O浪潮到直播之争，无不在抢占着每一个新产业新技术的市场，而这些产业的兴起与回到本位，都在影响着我们的技术发展。</p><p>所以，我们应该偶尔尝试着跳出自己的惯性思维圈子，到思维的墙外去看一看。</p><h2 id="来个总结程词"><a href="#来个总结程词" class="headerlink" title="来个总结程词"></a>来个总结程词</h2><p>差不多就说完了，当下我仍然是个大数据领域的小菜鸟，希望自己的一点心得能给各位一些帮助，往后的路任重而道远~</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/25/168844730c8d9839?w=251&amp;h=76&amp;f=png&amp;s=6149" alt=""></p><p><strong>抛砖引玉</strong>：形容搬砖的人为了获得大佬的真知灼见将自己的砖扔了出去(逃</p><h4 id="顺便再给2019年立几个flag"><a href="#顺便再给2019年立几个flag" class="headerlink" title="顺便再给2019年立几个flag~"></a>顺便再给2019年立几个flag~</h4><ul><li>写10篇技术文章</li><li>将手上的项目都做完</li><li>读5本非职业相关的书</li><li>身体更加健康，苗条</li><li>去看更多的世界(地理意义上的)</li></ul><p>祝各位小伙伴~大吉大利~比心~</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/25/168845df7bb37efa?w=52&amp;h=46&amp;f=png&amp;s=4881" alt=""></p><p>最后附上一段摘自<a href="https://blog.douban.com/douban/2016/02/16/3099/" target="_blank" rel="noopener">豆瓣的句子</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我张开双臂拥抱世界</span><br><span class="line">世界也拥抱我</span><br><span class="line">I embrace the world with open arms</span><br><span class="line">And the world embraces me</span><br><span class="line"></span><br><span class="line">我经历的</span><br><span class="line">或未经历的</span><br><span class="line">都是我想表达的</span><br><span class="line">all that I have experienced</span><br><span class="line">and that which I am yet to experience</span><br><span class="line">is what I want to express</span><br><span class="line"></span><br><span class="line">我自由，渴望交流</span><br><span class="line">懂得与人相处</span><br><span class="line">但不强求共鸣</span><br><span class="line">I’m free-spirited and crave conversation</span><br><span class="line">I seek to understand how best to communicate with others</span><br><span class="line">Whilst never seeking recognition</span><br></pre></td></tr></table></figure></p><p><br><br>———— 2019.01.25于杭州</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没有更新文章了，一抬头已是2019年了，这一晃从转行至今已经过去1年了，日子过得越来越匆忙，也是时候停下&lt;del&gt;摸鱼的&lt;/del&gt;脚步，做个小总结了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/25/1
      
    
    </summary>
    
      <category term="经验总结" scheme="http://yoursite.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="吐槽" scheme="http://yoursite.com/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_21 合并两个有序链表 easy</title>
    <link href="http://yoursite.com/2018/11/20/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_21/"/>
    <id>http://yoursite.com/2018/11/20/leetcode萌新练级_round1_21/</id>
    <published>2018-11-20T03:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>合并两个有序链表</strong></p><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Merge Two Sorted Lists</strong></p><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题还是挺简单的，就是始终记不住链表的使用//(ㄒoㄒ)//~~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1, l2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        a = b = ListNode(0)</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt;= l2.val:</span><br><span class="line">                b.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            else:</span><br><span class="line">                b.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            b = b.next</span><br><span class="line">        if l1 or l2:</span><br><span class="line">            b.next = l1 or l2</span><br><span class="line">        return a.next</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(len(l1+l2))$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>56 ms</strong>, 在Merge Two Sorted Lists的Python3提交中击败了<strong>95.89%</strong> 的用户</p><p>官方排行里的代码，运行了之后时间还不如我自己写的(摊手)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;合并两个有序链表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_20 有效的括号 easy</title>
    <link href="http://yoursite.com/2018/11/16/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_20/"/>
    <id>http://yoursite.com/2018/11/16/leetcode萌新练级_round1_20/</id>
    <published>2018-11-16T09:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>有效的括号</strong></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Valid Parentheses</strong></p><blockquote><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>An input string is valid if:<br>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 3:</span><br><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 5:</span><br><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题还是挺简单的，就是运行时间排行有点感人//(ㄒoㄒ)//~~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        a = &#123;</span><br><span class="line">            &apos;(&apos; : &apos;)&apos;,</span><br><span class="line">            &apos;[&apos; : &apos;]&apos;,</span><br><span class="line">            &apos;&#123;&apos; : &apos;&#125;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        li = []</span><br><span class="line">        for i in s:</span><br><span class="line">            if a.get(i):</span><br><span class="line">                li.append(a[i])</span><br><span class="line">            elif len(li) == 0 or li[-1] != i:</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                li = li[:-1]</span><br><span class="line">        if len(li):</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>84 ms</strong>, 在Valid Parentheses的Python3提交中击败了<strong>3.82%</strong> 的用户</p><p>再看看答案中排名靠前的运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">def isValid(self, s):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">:type s: str</span><br><span class="line">:rtype: bool</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">map_ = &#123;&apos;)&apos;: &apos;(&apos;, &apos;&#125;&apos;: &apos;&#123;&apos;, &apos;]&apos;: &apos;[&apos;&#125;</span><br><span class="line">stack = []</span><br><span class="line">for char_ in s:</span><br><span class="line">if char_ in map_:</span><br><span class="line">top_element = stack.pop() if stack else &quot;#&quot;</span><br><span class="line">if map_[char_] != top_element:</span><br><span class="line">return False</span><br><span class="line">else:</span><br><span class="line">stack.append(char_)</span><br><span class="line">return not stack</span><br></pre></td></tr></table></figure></p><p>执行用时: <strong>48 ms</strong>, 在Valid Parentheses的Python3提交中击败了<strong>76.80%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;有效的括号&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_19 删除链表的倒数第N个节点 medium</title>
    <link href="http://yoursite.com/2018/11/12/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_19/"/>
    <id>http://yoursite.com/2018/11/12/leetcode萌新练级_round1_19/</id>
    <published>2018-11-12T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>删除链表的倒数第N个节点</strong></p><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br><span class="line">说明：</span><br><span class="line">给定的 n 保证是有效的。</span><br><span class="line">进阶：</span><br><span class="line">你能尝试使用一趟扫描实现吗？</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Romove Nth Node From End of List</strong></p><blockquote><p>Given a linked list, remove the n-th node from the end of list and return its head.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br><span class="line">Note:</span><br><span class="line">Given n will always be valid.</span><br><span class="line">Follow up:</span><br><span class="line">Could you do this in one pass?</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题题目有提到，能不能只扫描一遍就实现，这个题其实一开始就是有思路的，就是扫描的时候，从最开始就让游标定在当前链的前n个数，当遇到结尾时，就将此时的游标节点跳过，只可惜不太会写链表，偷瞄了一下答案的写法，然后按照自己的思路，实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        fast = slower = head</span><br><span class="line">        for i in range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        while not fast:</span><br><span class="line">            return head.next</span><br><span class="line">        while fast.next:</span><br><span class="line">            slower = slower.next</span><br><span class="line">            fast = fast.next</span><br><span class="line">        slower.next = slower.next.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>56 ms</strong>, 在Remove Nth Node From End of List的Python3提交中击败了<strong>72.69%</strong> 的用户</p><p>再看看答案中排名靠前的运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not head or n&lt;1:</span><br><span class="line">            return None</span><br><span class="line">        fast=head</span><br><span class="line">        slow=head</span><br><span class="line">        for _ in range(n):</span><br><span class="line">            if not fast:</span><br><span class="line">                return None</span><br><span class="line">            fast=fast.next</span><br><span class="line">        if not fast:</span><br><span class="line">            return head.next</span><br><span class="line">        while fast.next:</span><br><span class="line">            fast=fast.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        slow.next=slow.next.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure></p><p>执行用时: <strong>48 ms</strong>, 在Remove Nth Node From End of List的Python3提交中击败了<strong>99.57%</strong> 的用户</p><p>将特殊情况放在最前面判断，一点点的细节，都会提高执行速度<em>(:зゝ∠)</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;删除链表的倒数第N个节点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_17 电话号码的字母组合 medium</title>
    <link href="http://yoursite.com/2018/10/30/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_17/"/>
    <id>http://yoursite.com/2018/10/30/leetcode萌新练级_round1_17/</id>
    <published>2018-10-30T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>电话号码的字母组合</strong></p><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://upload-images.jianshu.io/upload_images/5588611-f2d942d4898a9631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="phone_num.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br><span class="line">说明:</span><br><span class="line">尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Letter Combinations of a Phone Number</strong></p><blockquote><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br><span class="line">Note:</span><br><span class="line">Although the above answer is in lexicographical order, your answer could be in any order you want.</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这题又一次放弃了，找了python自带的笛卡尔积函数，但是不好用，<br>在英文讨论区找到了可以通过的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type digits: str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        mapping = &#123;</span><br><span class="line">            &apos;2&apos;:&apos;abc&apos;,</span><br><span class="line">            &apos;3&apos;:&apos;def&apos;,</span><br><span class="line">            &apos;4&apos;:&apos;ghi&apos;,</span><br><span class="line">            &apos;5&apos;:&apos;jkl&apos;,</span><br><span class="line">            &apos;6&apos;:&apos;mno&apos;,</span><br><span class="line">            &apos;7&apos;:&apos;pqrs&apos;,</span><br><span class="line">            &apos;8&apos;:&apos;tuv&apos;,</span><br><span class="line">            &apos;9&apos;:&apos;wxyz&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        if len(digits) == 0:</span><br><span class="line">            return []</span><br><span class="line">        if len(digits) == 1:</span><br><span class="line">            return list(mapping[digits[0]])</span><br><span class="line">        prev = self.letterCombinations(digits[:-1])</span><br><span class="line">        additional = mapping[digits[-1]]</span><br><span class="line">        return [s + c for s in prev for c in additional]</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O((3~4)^n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>48 ms</strong>, 在Letter Combinations of a Phone Number的Python3提交中击败了<strong>59.19%</strong> 的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def listCombinations(self, list_1, list_2):</span><br><span class="line">        ans = []</span><br><span class="line">        if len(list_1) == 0:</span><br><span class="line">            return list_2</span><br><span class="line">        if len(list_2) == 0:</span><br><span class="line">            return list_1</span><br><span class="line">        for c1 in list_1:</span><br><span class="line">            for c2 in list_2:</span><br><span class="line">                ans.append(c1+c2)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def letterCombinations(self, digits):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type digits: str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        &quot;&quot;&quot;      </span><br><span class="line">        ans = []</span><br><span class="line">        nums = &#123;&apos;2&apos;:&apos;abc&apos;,&apos;3&apos;:&apos;def&apos;,&apos;4&apos;:&apos;ghi&apos;,&apos;5&apos;:&apos;jkl&apos;,&apos;6&apos;:&apos;mno&apos;,&apos;7&apos;:&apos;pqrs&apos;,&apos;8&apos;:&apos;tuv&apos;,&apos;9&apos;:&apos;wxyz&apos;&#125;</span><br><span class="line">        for n in digits:</span><br><span class="line">            list_1 = list(nums[n])</span><br><span class="line">            ans = self.listCombinations(ans, list_1)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure><p>执行用时: <strong>44 ms</strong>, 在Letter Combinations of a Phone Number的Python3提交中击败了<strong>90.06%</strong> 的用户</p><p>敲代码是惊奇的发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line">for a in li1:</span><br><span class="line">    for b in li2:</span><br><span class="line">        li.append(a+b)</span><br></pre></td></tr></table></figure></p><p>比$[a+b for a in li1 for b in li2]$运算时间要短</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;电话号码的字母组合&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_16 最接近的三数之和 medium</title>
    <link href="http://yoursite.com/2018/10/25/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_16/"/>
    <id>http://yoursite.com/2018/10/25/leetcode萌新练级_round1_16/</id>
    <published>2018-10-25T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>最接近的三数之和</strong></p><blockquote><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>3Sum Closest</strong></p><blockquote><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这题直接放弃了，主要是懒得想，<br>在英文讨论区找到了可以通过的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSumClosest(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        N = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        result = nums[0] + nums[1] + nums[2]</span><br><span class="line">        for i in range(N):</span><br><span class="line">            s,e = i+1, N-1</span><br><span class="line">            while s &lt; e:</span><br><span class="line">                sums = nums[i] + nums[s] + nums[e]</span><br><span class="line">                if sums == target:</span><br><span class="line">                    return target</span><br><span class="line">                elif abs(sums - target) &lt; abs(result - target):</span><br><span class="line">                    result = sums</span><br><span class="line">                if sums &lt; target:</span><br><span class="line">                    s += 1</span><br><span class="line">                else:</span><br><span class="line">                    e -= 1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(\frac{(n-1)(n-2)}{2})$ (我猜的)<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>252 ms</strong>, 在3Sum Closest的Python3提交中击败了<strong>41.09%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;最接近的三数之和&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_15 三数之和 medium</title>
    <link href="http://yoursite.com/2018/10/24/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_15/"/>
    <id>http://yoursite.com/2018/10/24/leetcode萌新练级_round1_15/</id>
    <published>2018-10-24T14:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>三数之和</strong></p><blockquote><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>3Sum</strong></p><blockquote><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note:<br>The solution set must not contain duplicate triplets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>代码线下测试都通过了，又一次死在执行用时上了，<br>失败用例</p><p>贴一下失败的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        one_dict = &#123;&#125;</span><br><span class="line">        li = []</span><br><span class="line">        for id_i, v_i in enumerate(nums):</span><br><span class="line">            target = 0 - v_i</span><br><span class="line">            one_dict[v_i] = id_i</span><br><span class="line">            two_dict = &#123;&#125;</span><br><span class="line">            for id_j, v_j in enumerate(nums[id_i+1:]):</span><br><span class="line">                if target - v_j in two_dict:</span><br><span class="line">                    a = [v_i,target - v_j,v_j]</span><br><span class="line">                    a.sort()</span><br><span class="line">                    if a in li:</span><br><span class="line">                        pass</span><br><span class="line">                    else:</span><br><span class="line">                        li.append(a)</span><br><span class="line">                two_dict[v_j] = id_j + id_i + 1</span><br><span class="line">        return li</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(2)$</p><p>在英文讨论区找到了可以通过的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums.sort()</span><br><span class="line">        N, result = len(nums), []</span><br><span class="line">        for i in range(N):</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i-1]:</span><br><span class="line">                continue</span><br><span class="line">            target = nums[i]*-1</span><br><span class="line">            s,e = i+1, N-1</span><br><span class="line">            while s&lt;e:</span><br><span class="line">                if nums[s]+nums[e] == target:</span><br><span class="line">                    result.append([nums[i], nums[s], nums[e]])</span><br><span class="line">                    s = s+1</span><br><span class="line">                    while s&lt;e and nums[s] == nums[s-1]:</span><br><span class="line">                        s = s+1</span><br><span class="line">                elif nums[s] + nums[e] &lt; target:</span><br><span class="line">                    s = s+1</span><br><span class="line">                else:</span><br><span class="line">                    e = e-1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(\frac{(n-1)(n-2)}{2})$ (我猜的)<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>1260 ms</strong>, 在3Sum的Python3提交中击败了<strong>52.72%</strong> 的用户</p><p>通过之后，又在官网找到了比较快的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        temp_dict = &#123;&#125;</span><br><span class="line">        for num in nums:</span><br><span class="line">            temp_dict[num] = temp_dict.get(num, 0) + 1</span><br><span class="line">        small = sorted(filter(lambda key: key &lt; 0, temp_dict))</span><br><span class="line">        big = sorted(filter(lambda key: key &gt; 0, temp_dict))</span><br><span class="line">        if 0 in temp_dict and temp_dict[0] &gt; 2:</span><br><span class="line">            res = [[0, 0, 0]]</span><br><span class="line">        else:</span><br><span class="line">            res = []</span><br><span class="line">        for i in small:</span><br><span class="line">            for j in big:</span><br><span class="line">                diff = -i - j</span><br><span class="line">                if diff in temp_dict:</span><br><span class="line">                    if diff in (i, j) and temp_dict[diff] &gt; 1:</span><br><span class="line">                        res.append([i, diff, j])</span><br><span class="line">                    elif i &lt; diff &lt; j:</span><br><span class="line">                        res.append([i, diff, j])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></p><p>执行用时: <strong>448 ms</strong>, 在3Sum的Python3提交中击败了<strong>99.87%</strong> 的用户</p><p>惊为天人，膜拜一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;三数之和&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_14 最长公共前缀 easy</title>
    <link href="http://yoursite.com/2018/10/24/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_14/"/>
    <id>http://yoursite.com/2018/10/24/leetcode萌新练级_round1_14/</id>
    <published>2018-10-24T01:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>最长公共前缀</strong></p><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">说明:</span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Longest Common Prefix</strong></p><blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.<br>If there is no common prefix, return an empty string “”.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line">Note:</span><br><span class="line">All given inputs are in lowercase letters a-z.</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这道题解法一开始都写出来了，但最终提交了4次才通过，主要是没有考虑极限情况，当数组为空，当字符串为空时，如何处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        s = &quot;&quot;</span><br><span class="line">        j = 0</span><br><span class="line">        if not len(strs):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        while True:</span><br><span class="line">            for i in range(len(strs)):</span><br><span class="line">                if len(strs[i]) &lt;= j:</span><br><span class="line">                    return s</span><br><span class="line">                a = strs[0][j]</span><br><span class="line">                if a == strs[i][j]:</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    return s</span><br><span class="line">            s += a</span><br><span class="line">            j += 1</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(s)$ s是所有字符串相加<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>56 ms</strong>, 在Longest Common Prefix的Python3提交中击败了<strong>51.54%</strong> 的用户</p><p>发现可以在提交成功之后，查看排行榜中的优秀代码，<a href="https://jingyan.baidu.com/article/22fe7cedfcdccb3002617f87.html" target="_blank" rel="noopener">方法</a>，但是我把耗时在30+ms的代码跑了一遍，在我这里依旧是52ms= =，所以这个运行时间，也会看电脑性能的吗……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;最长公共前缀&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_13 罗马数字转整数 easy</title>
    <link href="http://yoursite.com/2018/10/23/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_13/"/>
    <id>http://yoursite.com/2018/10/23/leetcode萌新练级_round1_13/</id>
    <published>2018-10-23T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>罗马数字转整数</strong></p><blockquote><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Roman to Integer</strong></p><blockquote><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.<br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:<br>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>有了12题的基础，这道题基本一遍过，但是时间还是有点长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        value_dicts = &#123;&apos;M&apos;:1000, &apos;D&apos;:500, &apos;C&apos;:100, &apos;L&apos;:50, &apos;X&apos;:10, &apos;V&apos;:5, &apos;I&apos;:1&#125;</span><br><span class="line">        index = &apos;I&apos;</span><br><span class="line">        sum_num = 0</span><br><span class="line">        for i in s[::-1]:</span><br><span class="line">            if value_dicts[i] &gt;= value_dicts[index]:</span><br><span class="line">                sum_num += value_dicts[i]</span><br><span class="line">                index = i</span><br><span class="line">            else:</span><br><span class="line">                sum_num -= value_dicts[i]</span><br><span class="line">                index = i</span><br><span class="line">        return sum_num</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>212 ms</strong>, 在Roman to Integer的Python3提交中击败了<strong>41.50%</strong> 的用户</p><p>没有找到更快的代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;罗马数字转整数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_12 整数转罗马数字 medium</title>
    <link href="http://yoursite.com/2018/10/23/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_12/"/>
    <id>http://yoursite.com/2018/10/23/leetcode萌新练级_round1_12/</id>
    <published>2018-10-23T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>整数转罗马数字</strong></p><blockquote><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Integer to Roman</strong></p><blockquote><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.<br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:<br>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题直接看的英文版官网里的讨论，大家都表示这是一道很糟糕的题型(其实我也这么觉得)，看了java的解法，照着写了一遍python3的，看完解法之后更加觉得这是一个很糟糕的题目了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        li = []</span><br><span class="line">        values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</span><br><span class="line">        strs = [&apos;M&apos;, &apos;CM&apos;, &apos;D&apos;, &apos;CD&apos;, &apos;C&apos;, &apos;XC&apos;, &apos;L&apos;, &apos;XL&apos;, &apos;X&apos;, &apos;IX&apos;, &apos;V&apos;, &apos;IV&apos;, &apos;I&apos;]</span><br><span class="line">        for i in range(len(values)):</span><br><span class="line">            while num &gt;= values[i]:</span><br><span class="line">                num -= values[i]</span><br><span class="line">                li.append(strs[i])</span><br><span class="line">        return &apos;&apos;.join(li)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>140 ms</strong>, 在Integer to Roman的Python3提交中击败了<strong>94.12%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;整数转罗马数字&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_11 盛最多水的容器 medium</title>
    <link href="http://yoursite.com/2018/10/19/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_11/"/>
    <id>http://yoursite.com/2018/10/19/leetcode萌新练级_round1_11/</id>
    <published>2018-10-19T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>盛最多水的容器</strong></p><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Palindrome Number</strong></p><blockquote><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.<br>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>自己写的代码，42/50个通过了测试用例，挂在一个超长的序列中(这句话似曾相识)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[28,342,418,485,719,670,878,752,662,994,654,504,929,660,424,855,922,744,600,229,728,33,371,863,561,772,271,178,455,449,426,835,143,845,321,214,867,199,967,881,193,973,386,122,633,810,330,907,906,282,136,986,315,860,849,229,632,473,759,87,922,185,922,418,382,243,632,250,795,599,131,988,924,869,463,558,680,145,465,938,427,954,925,94,814,126,323,798,599,434,885,874,620,159,292,354,755,924,956,550,876,88,890,800,309,705,358,989,850,176,280,629,130,205,724,296,331,399,94,283,186,331,157,806,490,801,512,597,725,469,499,601,909,390,754,218,447,112,560,298,640,840,279,122,397,355,418,80,755,864,363,293,195,872,451,38,673,963,635,751,432,487,352,341,229,458,912,676,923,472,326,563,312,606,686,709,313,456,789,420,321,505,713,868,377,164,258,403,128,246,154,912,733,858,606,962,317,518,990,240,990,317,803,302,275,841,363,588,650,504,9,323,9,74,191,387,239,450,790,367,48,944,279,781,802,885,743,471,755,85,711,745,402,867,399,29,708,762,970,710,267,331,33,276,405,577,15,644,379,157,363,427,453,995,208,608,232,303,79,988,388,791,733,143,658,133,524,718,247,846,429,514,529,814,143,935,743,510,931,122,668,647,901,473,642,461,81,874,764,513,214,505,304,948,0,314,433,876,384,680,75,165,547,604,980,42,891,75,552,823,198,572,822,451,46,816,913,479,42,29,992,257,886,648,557,238,962,990,115,699,22,190,864,921,794,196,315,686,272,868,861,822,792,35,273,190,851,186,670,893,568,662,150,454,311,59,693,625,49,808,324,424,350,189,697,496,737,13,534,9,881,747,831,25,782,457,216,985,643,886,879,211,900,381,18,211,441,711,837,842,871,513,618,573,702,316,69,440,329,956,801,562,703,633,587,486,90,803,471,85,41,702,649,942,436,19,505,877,730,342,71,953,856,690,526,910,6,947,702,335,903,504,249,607,489,836,445,931,992,268,368,33,971,369,327,407,388,833,636,470,527,59,423,735,749,301,646,107,249,700,794,504,556,43,111,397,232,908,328,224,177,49,609,500,418,937,259,159,770,247,629,297,306,405,33,408,706,31,867,955,83,662,460,640,57,923,37,289,832,718,865,361,119,475,213,537,412,472,48,534,71,678,183,377,83,568,137,141,599,5,449,35,19,261,675,76,184,64,366,368,134,583,81,253,58,294,143,822,118,191,356,189,221,892,919,656,460,56,798,412,61,247,447,80,508,474,509,44,538,227,765,673,810,846,278,869,493,421,43,611,613,752,153,834,644,72,491,456,128,641,868,542,888,315,974,748,141,483,144,32,710,909,705,873,108,983,94,601,757,137,564,370,241,69,556,885,141,47,694,622,688,562,516,928,230,490,28,371,326,173,403,388,82,460,613,542,796,707,495,553,197,412,275,438,481,831,676,623,231,370,597,271,284,113,200,514,955,228,238,633,753,993,374,188,806,987,730,602,695,226,507,892,638,782,330,471,965,358,94,196,728,43,468,365,508,20,879,464,600,469,449,354,463,823,542,621,811,624,223,506,850,82,750,840,216,432,312,181,791,758,730,871,802,550,236,310,570,468,126,522,289,576,228,104,751,122,725,562,747,300,420,949,382,170,790,950,603,454,132,746,564,214,969,366,764,206,29,686,26,507,208,315,435,789,420,187,911,145,101,658,446,522,608,180,692,750,131,647,556,615,393,120,181,363,839,945,921,220,983,299,727,543,614,515,332,386,54,244,884,155,254,682,29,214,862,722,964,345,721,520,960,467,993,141,182,832,438,455,52,421,754,131,317,720,646,649,107,52,245,343,208,500,25,589,714,239,311,31,585,385,903,897,852,896,391,386,728,181,841,780,955,595,264,272,315,262,921,774,315,167,117,875,19,494,464,733,86,128,116,671,513,20,920,717,916,663,103,997,845,944,129,800,891,393,72,558,656,345,333,971,512,802,846,883,649,662,617,735,790,733,406,655,105,678,372,374,342,827,371,187,123,500,339,14,246,411,573,902,108,258,225,973,60,423,856,709,85,473,444,876,559,202,531,16,233,256,390,575,83,761,114,559,614,453,573,860,216,498,114,324,756,339,649,169,762,506,230,199,979,27,427,890,581,311,259,814,567,649,389,2,763,855,561,377,660,487,589,228,337,703,905,446,42,554,615,156,60,197,707,392,576,135,282,158,446,541,324,365,543,66,367,306,921,281,35,582,768,624,810,457,327,715,903,721,270,870,229,682,68,936,74,996,423,709,154,221,250,479,586,145,545,306,451,818,587,486,400,707,462,563,164,789,630,420,862,252,290,443,935,358,732,9,355,155,718,861,729,321,692,315,466,237,973,270,56,560,108,808,619,571,723,136,712,354,556,927,958,846,370,893,557,454,255,264,610,325,477,339,998,170,6,817,759,980,87,815,892,547,976,864,470,51,0,183,405,908,462,716,754,184,961,663,639,216,927,249,894,405,940,892,927,298,709,686,630,148,854,523,696,830,387,166,881,739,701,639,647,163,707,401,348,668,417,987,237,344,588,131,101,880,375,28,178,85,67,161,233,921,684,929,103,423,448,984,162,149,975,809,665,682,562,13,703,979,352,940,676,940,423,777,172,798,158,702,883,225,863,469,498,899,750,601,322,198,937,484,348,265,293,365,299,856,378,2,187,82,294,863,374,717,993,546,516,151,248,751,728,464,220,578,363,971,179,686,169,116,522,869,381,168,234,681,376,964,35,563,46,330,427,420,47,420,318,915,923,919,667,3,383,239,581,98,562,760,136,732,228,659,953,962,827,540,995,203,856,30,118,903,712,545,675,112,317,994,27,240,913,46,243,648,638,824,746,200,936,883,284,165,894,590,127,721,130,474,276,986,504,394,241,217,292,269,329,609,263,708,202,528,107,797,176,745,974,274,945,910,157,582,427,403,172,906,124,302,380,752,640,885,499,234,454,791,503,135,752,118,843,954,646,302,104,174,47,78,800,345,988,310,927,416,713,99,322,838,753,55,942,745,940,441,979,746,584,482,881,337,952,76,643,598,379,747,124,778,825,925,123,166,235,402,934,948,853,608,138,606,663,81,704,955,874,683,701,459,518,934,148,470,363,791,421,94,891,545,872,68,822,348,234,57,102,168,358,956,129,496,914,792,929,618,748,804,654,801,263,524,736,411,994,451,554,767,545,797,313,769,866,487,117,452,545,572,973,903,528,102,751,442,246,681,413,994,485,67,148,100,591,236,863,937,687,417,705,232,567,370,353,433,857,823,237,754,395,210,9,923,664,113,717,911,794,482,257,631,549,405,83,492,641,946,782,328,715,839,912,282,561,266,715,418,89,305,525,484,515,534,759,532,999,476,443,793,959,700,776,860,106,859,705,99,805,839,428,873,678,692,155,239,958,223,9,399,528,886,235,395,773,994,927,772,823,722,566,134,423,694,346,881,554,403,332,711,242,760,584,272,805,740,863,763,315,873,515,843,759,750,238,884,745,518,657,568,240,575,54,15,269,400,248,175,804,581,887,398,693,823,671,498,915,534,262,230,759,129,425,871,879,664,755,624,534,412,544,774,987,950,790,257,351,390,784,507,971,671,905,665,847,928,163,762,463,777,345,574,906,770,445,786,786,201,762,320,965,659,95,953,609,237,562,312,979,346,819,951,370,77,616,569,357,131,331,820,909,28,747,167,799,192,953,585,745,68,906,711,727,353,16,688,942,930,1,921,628,172,224,350,601,192,919,959,324,251,131,585,279,878,752,430,423,58,16,168,126,274,231,205,979,247,893,921,177,246,194,158,419,419,508,20,963,428,331,639,31,463,224,662,341,329,93,764,739,461,285,217,735,516,422,714,764,667,987,293,914,533,451,685,304,960,57,268,740,389,907,771,852,484,433,545,165,878,310,904,339,947,121,426,463,895,492,579,914,831,873,828,365,676,865,21,988,923,289,728,312,549,851,516,385,637,61,550,515,723,806,207,670,927,985,134,174,478,713,88,309,938,269,26,615,134,48,955,409,689,684,721,590,887,589,975,524,651,877,392,726,683,599,397,962,584,883,136,414,948,577,724,239,846,102,206,332,150,161,742,192,197,815,782,85,405,758,609,408,635,353,134,671,952,883,633,889,118,122,655,419,699,731,658,897,834,216,229,336,377,323,528,927,139,311,12,896,69,973,304,56,679,790,727,631,674,361,872,792,483,528,563,534,259,221,431,445,437,12,782,167,336,310,94,827,621,458,723,42,783,379,99,462,169,826,446,843,539,670,988,374,550,551,908,162,125,691,607,914,704,389,81,392,52,527,571,673,337,294,716,473,25,167,935,194,993,733,38,885,404,378,259,306,281,168,468,406,211,76,321,915,817,754,659,869,634,230,895,323,876,611,796,253,778,84,448,123,817,838,8,573,216,268,880,849,788,348,256,999,776,929,267,594,683,278,815,669,861,710,993,89,673,789,343,803,225,791,927,43,981,287,968,549,907,848,398,47,549,654,47,325,583,666,271,619,944,439,640,805,149,633,895,175,775,590,978,0,381,257,395,714,545,364,263,804,564,661,852,113,668,899,791,603,917,414,222,861,205,863,19,355,848,914,530,623,856,860,976,237,118,371,303,15,87,566,819,652,579,671,117,247,922,260,851,839,27,425,53,232,640,72,587,489,338,469,464,194,682,440,783,800,812,86,167,899,652,986,903,231,10,21,831,284,281,682,476,308,107,529,893,748,601,832,589,939,302,53,485,336,494,268,136,658,354,303,909,358,641,813,941,651,186,772,288,467,454,764,128,914,293,21,14,246,853,603,537,507,656,22,843,502,290,331,160,996,986,70,706,628,235,647,631,421,420,919,888,226,35,368,492,328,741,506,926,947,461,463,806,118,485,2,972,127,685,133,475,672,555,181,652,790,181,635,211,953,555,451,179,942,820,24,271,913,530,197,212,992,13,19,462,850,373,434,330,58,919,805,82,474,339,734,264,872,370,475,825,277,927,4,219,99,380,842,364,911,392,577,255,405,948,69,255,321,855,585,731,775,743,814,601,434,548,866,306,270,693,131,547,620,487,119,71,868,961,436,131,705,365,738,110,313,159,366,986,14,303,717,141,398,883,743,832,432,961,138,54,654,621,954,627,109,73,698,329,386,486,812,92,851,550,554,516,709,920,502,75,576,572,217,974,455,312,807,239,273,297,646,927,919,600,906,380,25,957,61,763,443,873,207,647,423,762,163,484,34,18,559,610,942,128,937,749,440,96,341,65,393,987,993,664,587,251,396,964,208,457,727,652,330,935,651,105,697,166,589,731,536,501,694,478,981,631,580,422,727,921,839,472,908,832,137,847,84,533,811,644,991,538,296,673,825,299,779,522,466,720,606,2,221,300,833,203,283,413,977,362,334,816,834,594,1,323,441,437,209,604,81,552,142,730,225,968,29,4,842,847,77,448,850,298,100,35,853,735,448,182,97,134,351,284,728,704,959,521,493,168,125,926,720,619,8,946,939,390,302,782,237,731,582,439,30,35,474,235,770,922,770,220,408,473,856,136,529,815,9,374,984,486,300,704,106,661,2,45,51,657,179,640,388,114,80,770,149,554,358,271,829,480,843,237,953,699,726,834,515,735,208,851,222,508,555,680,521,910,77,572,919,609,213,307,723,293,430,872,199,788,495,28,268,339,618,573,38,344,407,905,431,615,756,5,475,664,685,997,574,115,921,493,724,134,152,447,779,582,671,331,370,518,359,990,857,329,563,248,673,322,153,105,289,262,462,765,926,500,114,852,615,35,345,691,522,849,490,653,432,513,984,154,31,696,145,889,25,60,489,51,383,642,508,672,904,970,789,182,470,255,34,437,643,731,128,165,581,618,170,13,483,155,519,515,203,664,756,228,77,245,631,812,239,139,836,496,110,978,678,932,233,713,722,876,796,850,41,377,821,564,742,304,719,262,171,274,278,927,502,355,524,486,519,764,625,356,612,87,334,642,20,567,707,742,444,504,944,837,881,117,401,624,774,472,238,945,746,516,225,601,224,749,87,743,513,64,99,477,152,785,120,524,705,827,266,501,331,562,338,213,32,92,189,806,916,427,103,15,295,328,968,519,78,407,263,943,471,714,421,623,852,541,147,557,368,765,58,700,680,748,265,712,192,454,870,109,233,973,476,528,302,444,48,380,851,663,323,674,729,744,650,581,637,149,490,6,267,548,58,947,297,323,11,841,129,881,950,362,206,778,890,508,222,290,240,425,305,916,100,387,660,102,320,298,251,811,656,518,711,714,817,360,37,828,202,518,61,504,880,268,283,122,128,857,765,369,283,422,637,735,809,297,189,482,947,440,645,955,959,356,669,776,69,58,957,271,576,18,127,808,638,410,931,119,268,48,840,903,470,477,990,632,126,179,114,426,971,759,381,930,467,403,59,536,813,16,159,742,386,287,550,377,49,833,496,317,881,688,572,352,165,914,336,291,445,450,69,417,561,451,699,380,206,110,917,19,478,428,761,217,715,664,594,765,497,442,434,379,130,359,83,647,625,419,290,423,221,360,192,134,163,891,514,369,2,783,740,832,564,854,49,279,518,643,396,15,437,183,746,919,894,829,566,519,600,857,294,173,217,486,307,380,378,174,101,732,309,841,916,873,695,966,505,213,961,253,229,399,788,975,318,682,157,885,554,109,742,848,283,311,335,942,691,65,468,792,149,778,985,65,3,681,31,860,894,345,466,475,744,254,803,62,289,312,299,843,421,393,43,56,704,730,999,747,147,467,891,648,597,877,714,953,558,97,813,804,442,279,632,538,534,787,953,823,99,252,18,872,998,413,929,702,496,280,802,643,747,693,292,697,570,358,650,128,807,463,285,602,95,917,140,629,704,445,804,155,50,174,27,48,939,308,750,435,588,904,431,688,598,723,385,168,433,35,649,592,850,934,194,945,203,687,926,907,132,730,414,182,256,793,582,196,102,685,983,690,589,414,378,187,489,115,356,922,150,357,867,1,291,61,946,494,100,873,753,585,955,167,119,564,312,702,760,414,387,95,457,976,510,187,516,999,303,224,274,453,581,141,806,872,554,105,718,655,978,471,592,285,990,711,849,302,765,961,69,504,57,526,833,567,713,349,918,368,573,192,174,154,333,980,378,888,85,96,895,415,919,487,701,261,550,902,915,668,216,984,172,273,862,5,192,928,706,462,296,279,655,470,785,340,451,163,580,888,611,827,304,882,314,357,143,217,611,59,237,827,395,409,100,258,767,644,186,473,107,482,105,114,305,890,806,756,406,387,996,17,214,300,900,881,9,43,450,621,454,687,448,850,96,901,460,215,897,646,689,356,480,794,470,785,36,277,893,442,16,890,460,230,542,712,111,904,107,913,525,562,600,973,764,49,226,224,264,124,222,953,480,54,99,303,192,136,580,437,578,948,679,390,178,222,102,642,478,210,555,3,772,156,328,888,557,907,464,821,31,38,775,863,444,226,166,636,362,98,74,293,46,753,683,577,327,786,219,157,996,126,160,120,634,841,360,191,748,824,13,131,862,140,994,306,718,513,295,81,611,721,726,10,826,409,587,506,547,158,663,543,284,824,15,919,17,375,462,765,199,475,896,413,967,242,72,686,755,367,119,367,440,845,729,266,606,316,772,154,474,436,697,110,612,65,29,629,440,844,746,992,319,994,405,639,236,829,677,992,548,796,711,988,993,440,255,599,108,27,105,934,815,155,44,427,220,74,408,660,918,154,652,589,148,410,580,737,239,257,729,788,405,792,776,750,584,383,702,692,763,807,626,578,962,670,358,182,96,766,195,366,273,199,308,421,609,240,158,201,850,239,341,255,31,469,6,967,853,60,659,616,867,637,546,182,660,904,364,108,671,911,475,944,111,135,717,72,375,228,273,225,819,614,833,203,84,191,170,289,251,830,905,470,819,803,652,479,708,369,588,731,280,415,27,743,902,744,816,277,324,441,855,144,56,40,347,492,583,869,781,834,51,38,656,871,841,309,350,549,678,290,632,310,705,659,406,607,756,222,237,80,15,444,576,423,484,275,915,419,145,48,253,196,86,909,67,280,570,770,181,600,60,814,263,118,473,669,725,229,243,314,662,258,758,238,682,594,514,597,13,659,998,618,207,436,880,275,716,802,45,250,403,457,64,666,575,889,335,301,471,930,967,133,188,726,723,870,672,237,820,38,248,818,656,456,606,536,83,323,339,128,925,94,937,989,112,513,230,799,166,701,729,133,186,917,211,910,788,884,499,960,922,748,130,930,556,736,819,639,411,510,119,336,604,56,677,716,569,908,515,87,961,244,221,500,513,784,410,653,20,909,613,294,9,743,225,565,480,44,204,891,906,323,580,510,732,257,578,653,517,445,741,479,41,314,979,554,98,741,208,471,2,173,765,12,917,990,577,749,386,134,992,292,809,572,154,541,830,84,195,347,529,288,178,570,602,509,477,52,250,685,523,253,858,641,265,127,631,194,876,370,680,869,14,490,441,169,383,623,253,930,971,135,218,149,705,820,659,534,225,261,219,100,514,430,741,131,909,373,678,138,95,358,7,109,200,800,630,936,424,236,866,747,371,85,248,428,257,259,963,482,521,534,583,387,316,324,871,226,49,549,364,496,259,723,958,812,875,588,748,651,176,614,398,547,51,999,328,309,258,291,143,131,825,726,871,494,403,94,72,804,995,436,301,254,511,611,418,738,199,518,390,376,133,140,275,184,139,603,845,750,246,989,233,424,67,456,918,470,550,990,627,545,778,280,152,641,891,570,379,90,89,121,818,574,262,446,110,753,401,956,855,648,945,441,424,12,249,694,835,800,684,462,697,814,742,849,807,633,772,538,75,213,660,246,787,274,44,249,379,445,205,587,445,502,380,869,867,629,563,54,429,599,868,479,765,610,328,572,595,452,463,22,665,123,620,804,749,664,54,480,110,611,67,907,466,447,129,685,77,692,739,858,644,607,337,761,569,18,686,516,470,149,538,136,624,159,292,373,175,698,853,285,310,273,545,128,720,674,165,149,718,904,8,714,863,345,476,784,715,162,300,186,311,190,674,287,701,966,660,877,665,865,514,327,138,59,807,211,733,972,360,804,876,720,518,91,418,994,875,133,508,175,319,819,717,993,458,419,312,470,296,977,336,810,656,826,870,463,389,955,435,750,759,311,470,630,754,888,624,629,374,133,156,693,304,873,39,763,292,351,233,940,680,921,751,336,100,973,799,489,280,234,239,392,545,62,22,299,302,998,280,676,483,436,722,788,309,761,903,954,464,488,894,144,410,997,480,510,970,279,351,603,513,591,995,410,5,369,61,659,367,341,688,851,129,410,991,438,523,894,744,987,382,639,131,144,988,611,6,311,242,358,914,755,301,261,517,306,630,578,317,349,919,5,552,48,415,543,838,290,789,935,277,524,926,760,668,914,371,675,225,965,33,491,72,686,752,589,992,734,167,661,436,438,667,988,838,434,884,29,725,673,964,354,197,242,115,218,156,838,893,734,804,278,225,876,964,330,466,308,416,985,969,852,776,988,841,614,775,725,995,500,750,311,854,948,553,969,166,62,808,411,796,964,41,373,840,357,703,658,17,120,996,338,324,772,327,165,738,102,242,86,954,993,397,160,293,303,130,459,365,290,222,513,606,615,886,446,972,942,457,989,414,453,327,738,577,6,904,315,460,498,401,414,491,151,575,784,454,57,595,819,699,169,332,305,784,570,103,108,512,560,449,926,365,777,665,942,135,921,610,596,419,11,362,911,514,289,47,968,698,643,787,397,164,471,54,949,42,158,57,906,70,507,833,788,636,850,730,123,123,692,71,542,56,434,805,570,75,853,539,774,848,678,171,12,150,578,313,544,736,723,802,158,230,987,946,218,837,29,693,960,721,765,855,777,199,660,348,274,865,239,400,713,917,924,78,419,502,391,315,590,114,118,748,696,105,47,266,295,428,960,255,149,725,110,279,924,123,979,550,988,218,951,702,135,875,780,907,729,523,222,319,638,340,419,686,798,466,953,93,894,913,700,396,638,163,675,914,286,654,816,274,224,119,328,359,994,460,618,75,984,841,394,974,533,166,660,331,984,613,776,879,526,477,627,516,992,654,430,278,660,599,904,884,718,233,595,65,45,214,140,29,407,887,3,940,53,16,624,37,629,752,268,508,581,895,376,573,901,807,851,561,406,756,445,124,341,393,541,386,607,682,768,14,569,123,306,622,139,282,11,121,35,280,981,616,527,357,190,429,164,393,342,922,149,788,399,842,181,940,229,140,974,997,506,543,120,812,517,612,95,881,733,130,161,714,746,40,71,288,469,588,682,164,862,183,952,613,26,485,906,607,977,880,604,483,776,76,295,645,40,742,526,125,872,39,839,971,80,263,611,901,203,293,65,417,829,369,383,855,206,289,462,183,521,418,18,649,846,314,295,887,408,173,12,633,213,204,604,645,819,567,898,374,213,316,143,42,685,526,897,244,815,711,427,689,481,446,338,327,112,633,566,520,159,931,153,724,487,109,721,306,677,619,32,242,935,175,284,973,54,181,217,869,244,996,910,725,442,249,52,906,234,971,779,393,902,932,469,389,394,190,47,423,810,431,665,97,958,949,70,12,482,639,234,726,636,144,451,430,393,855,337,628,826,116,373,80,400,843,469,794,33,868,569,195,299,234,293,258,183,715,622,17,355,856,743,991,1,546,421,394,402,110,374,228,226,748,309,979,943,130,773,976,351,695,524,2,929,817,612,465,884,235,482,239,91,226,582,92,772,4,839,526,466,213,107,45,313,768,24,256,250,149,585,601,844,109,604,774,278,216,239,162,803,73,402,895,299,984,339,424,340,178,302,159,744,409,204,57,177,228,666,428,729,251,381,574,360,985,700,990,554,291,152,357,364,906,604,16,243,944,792,583,474,94,94,570,504,298,980,33,526,646,813,608,249,195,182,961,532,882,951,438,525,103,796,889,10,752,905,253,696,49,188,523,144,635,93,0,933,425,385,812,71,551,420,320,746,602,281,630,836,584,69,361,688,217,602,50,969,860,655,18,909,195,541,405,830,986,757,764,412,143,928,835,694,348,508,792,302,141,422,490,726,491,851,766,708,805,816,30,665,823,48,927,370,941,332,201,279,90,317,43,585,245,879,279,945,387,71,247,880,845,737,606,689,940,372,749,97,540,779,115,363,179,42,86,120,374,287,400,816,956,443,401,553,674,32,498,413,455,97,294,301,186,900,990,478,625,91,575,165,871,690,881,50,732,967,523,459,606,923,627,914,718,29,467,393,413,317,158,869,766,452]</span><br></pre></td></tr></table></figure></p><p>失败原因是：<strong>超出时间限制</strong></p><p>贴一下失败的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        max_water = 0</span><br><span class="line">        for idx_i, v_i in enumerate(height):</span><br><span class="line">            for idx_j, v_j in enumerate(height[idx_i+1:]):</span><br><span class="line">                max_water = max((idx_j + 1) * min(v_i, v_j),max_water)</span><br><span class="line">        return max_water</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(1)$<br>官方其实也给出了这种方法(暴力法)，不过这种方法用python来运行实际上很容易超时</p><p>尝试使用官方给出的第二种方法，双指针法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        max_water = 0</span><br><span class="line">        l, r = 0, len(height) - 1</span><br><span class="line">        while (l &lt; r):</span><br><span class="line">            max_water = max(max_water, min(height[l], height[r]) * (r - l))</span><br><span class="line">            if height[l] &lt; height[r]:</span><br><span class="line">                l += 1</span><br><span class="line">            else:</span><br><span class="line">                r -= 1</span><br><span class="line">        return max_water</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>88 ms</strong>, 在Container With Most Water的Python3提交中击败了<strong>74.29%</strong> 的用户</p><p>在<a href="https://github.com/apachecn/awesome-algorithm/tree/master/docs/Leetcode_Solutions/Python" target="_blank" rel="noopener">网友的代码</a>中找到关于双指针法的解释</p><blockquote><p>由于ai和aj (i&lt;j) 组成的container的面积：S(i,j) = min(ai, aj) <em> (j-i)<br>当height[left] &lt; height[right]时，对任何left &lt; j &lt; right来说<br>min(height[left], height[j]) &lt;= height[left] = min(height[left], height[right])<br>j - left &lt; right - left<br>所以S(left, right) = min(height[left], height[right]) </em> (right-left) &gt; S(left, j) = min(height[left], height[j]) * (j-left)<br>这就排除了所有以left为左边界的组合，因此需要右移left。<br>因此：<br>height[left] &lt; height[right]，需要右移left.<br>同理，当height[left] &gt; height[right]时，需要左移right。<br>而当height[left] = height[right]时，需要同时移动left和right。<br>思路整理： left = 0, right = n-1<br>height[left] &lt; height[right], left++<br>height[left] &gt; height[right], right–<br>height[left] = height[right], left++, right–<br>终止条件：left &gt; right</p></blockquote><p>一开始不懂，看了解释之后豁然开朗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;盛最多水的容器&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_9 回文数 easy</title>
    <link href="http://yoursite.com/2018/10/18/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_9/"/>
    <id>http://yoursite.com/2018/10/18/leetcode萌新练级_round1_9/</id>
    <published>2018-10-18T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>回文数</strong></p><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>进阶:<br>你能不将整数转为字符串来解决这个问题吗？</strong></p><p><strong>Palindrome Number</strong></p><blockquote><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 121</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>一遍过，不过耗时还是有点多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if str(x) == str(x)[::-1]:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>440 ms</strong>, 在Palindrome Number的Python3提交中击败了<strong>30.44%</strong> 的用户</p><p>再考虑进阶要求，不使用字符串的方式解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        y = 0</span><br><span class="line">        if x &lt; 0 or (x % 10 == 0  and x != 0):</span><br><span class="line">            return False</span><br><span class="line">        while x &gt; y:</span><br><span class="line">            y = y * 10 + x % 10</span><br><span class="line">            x = int(x / 10)</span><br><span class="line">        return x == y or x == int(y / 10)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(log_{10}(n))$(官方说这个时间复杂度是这样，但我觉得时间复杂度应该是$O(\frac{1}{2}log_{10}(n))$)<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>408 ms</strong>, 在Palindrome Number的Python3提交中击败了<strong>51.63%</strong> 的用户<br>这里参考了官方的题解，反转其中一半的数字，通过求余和求除的方法，如果反转得到的数字与剩余的数字相等，就说明数字是回文数(奇数会考虑再除以10)，这样比反转整个数字时间要减少一半。</p><p>看<a href="https://github.com/apachecn/awesome-algorithm/tree/master/docs/Leetcode_Solutions/Python" target="_blank" rel="noopener">网友的代码</a>的时候发现，这道题以前是medium，现在难度已经变成easy了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if x &lt; 0 or (x != 0 and x % 10 == 0):</span><br><span class="line">            return False</span><br><span class="line">        rev, y = 0, x</span><br><span class="line">        while x &gt; 0:</span><br><span class="line">            rev = rev * 10 + x % 10</span><br><span class="line">            x = int(x / 10)</span><br><span class="line">        return y == rev</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(log_{10}(n))$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>328 ms</strong>, 在Palindrome Number的Python3提交中击败了<strong>83.72%</strong> 的用户</p><p>感觉很奇怪反转整个数字执行用时比反转一半时间短。。。。不是很明白。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;回文数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_8 字符串转整数(atoi) medium</title>
    <link href="http://yoursite.com/2018/10/17/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_8/"/>
    <id>http://yoursite.com/2018/10/17/leetcode萌新练级_round1_8/</id>
    <published>2018-10-17T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>字符串转整数(atoi)</strong></p><blockquote><p>实现 atoi，将字符串转为整数。<br>该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。<br>说明：<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。</span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>String to Interger(atoi)</strong></p><blockquote><p>Implement atoi which converts a string to an integer.<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.<br>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.<br>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.<br>If no valid conversion could be performed, a zero value is returned.<br>Note:<br>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical</span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题还是比较简单的，主要是要考虑到很多情况，一开始审题不是很严谨，所以提交的时候几次出错都是因为忽略了特殊情况，修改了几次后还是通过了。利用的是字符串遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type str: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        num = 0</span><br><span class="line">        x = 0</span><br><span class="line">        num2 = 0</span><br><span class="line">        for i in str:</span><br><span class="line">            if num2 == 0 and i == &apos; &apos;:</span><br><span class="line">                continue</span><br><span class="line">            elif x == 0 and num2 == 0 and i == &apos;-&apos;:</span><br><span class="line">                x = -1</span><br><span class="line">                num2 = 1</span><br><span class="line">            elif x == 0 and num2 == 0 and i == &apos;+&apos;:</span><br><span class="line">                x = 1</span><br><span class="line">                num2 = 1</span><br><span class="line">            elif i.isdigit():</span><br><span class="line">                num = num * 10 + int(i)</span><br><span class="line">                num2 = 1</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        if x == 0:</span><br><span class="line">            x = 1</span><br><span class="line">        if num &lt;= 0x7fffffff:</span><br><span class="line">            return num * x</span><br><span class="line">        elif x == 1:</span><br><span class="line">            return 2**31 - 1</span><br><span class="line">        else:</span><br><span class="line">            return -(2**31)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(3)$</p><p>执行用时: <strong>92 ms</strong>, 在String to Integer (atoi)的Python3提交中击败了<strong>45.26%</strong> 的用户</p><p><a href="https://github.com/apachecn/awesome-algorithm/tree/master/docs/Leetcode_Solutions/Python" target="_blank" rel="noopener">网友的代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">def myAtoi(self, str):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">:type str: str</span><br><span class="line">:rtype: int</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">str = str.strip()</span><br><span class="line">strNum = 0</span><br><span class="line">if len(str) == 0:</span><br><span class="line">return strNum</span><br><span class="line"></span><br><span class="line">positive = True</span><br><span class="line">if str[0] == &apos;+&apos; or str[0] == &apos;-&apos;:</span><br><span class="line">if str[0] == &apos;-&apos;:</span><br><span class="line">positive = False</span><br><span class="line">str = str[1:]</span><br><span class="line"></span><br><span class="line">for char in str:</span><br><span class="line">if char &gt;=&apos;0&apos; and char &lt;=&apos;9&apos;:</span><br><span class="line">strNum = strNum * 10 +  ord(char) - ord(&apos;0&apos;)</span><br><span class="line">if char &lt; &apos;0&apos; or char &gt; &apos;9&apos;:</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if strNum &gt; 2147483647:</span><br><span class="line">if positive == False:</span><br><span class="line">return -2147483648</span><br><span class="line">else:</span><br><span class="line">return 2147483647</span><br><span class="line">if not positive:</span><br><span class="line">strNum = 0 - strNum</span><br><span class="line">return strNum</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p>执行用时: <strong>88 ms</strong>, 在String to Integer (atoi)的Python3提交中击败了67.65% 的用户</p><p>异曲同工，处理方式差不多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;字符串转整数(atoi)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现 atoi，将字符串转为整数。&lt;br
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_7 反转整数 easy</title>
    <link href="http://yoursite.com/2018/10/16/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_7/"/>
    <id>http://yoursite.com/2018/10/16/leetcode萌新练级_round1_7/</id>
    <published>2018-10-16T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>反转整数</strong></p><blockquote><p>给定一个 32 位有符号整数，将整数中的数字进行反转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p></blockquote><p>注意:<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p><p><strong>Longest Palindromic Substring</strong></p><blockquote><p>Given a 32-bit signed integer, reverse digits of an integer.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p></blockquote><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题还是比较简单的，用了递归的方法，一开始没有设置溢出，设置溢出后，代码就通过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        i = 1</span><br><span class="line">        if x &lt; 0:</span><br><span class="line">            return -self.reverse(-x)</span><br><span class="line">        elif int(x / 10) == 0:</span><br><span class="line">            return  x</span><br><span class="line">        y = x % 10</span><br><span class="line">        res = y * 10**(len(str(x)) -1) + self.reverse(int(x/10))</span><br><span class="line">        return res if res &lt; 0x7fffffff else 0</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(log(x))$</p><p>空间复杂度：$O(1)$</p><p>执行用时: <strong>88 ms</strong>, 在Reverse Integer的Python3提交中击败了<strong>22.61%</strong> 的用户</p><p><a href="https://github.com/apachecn/awesome-algorithm/tree/master/docs/Leetcode_Solutions/Python" target="_blank" rel="noopener">网友的代码</a>(有一点小错误，我修改了一下)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if x &lt; 0:</span><br><span class="line">            return -self.reverse(-x)</span><br><span class="line">        res = 0</span><br><span class="line">        while x:</span><br><span class="line">            res = res * 10 + x % 10</span><br><span class="line">            x = int(x / 10)</span><br><span class="line">        return res if res &lt;= 0x7fffffff else 0</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(log(x))$</p><p>空间复杂度：$O(1)$</p><p>这个代码总体和我写的差不多，只是直接使用while来解决了迭代问题</p><p>执行用时: <strong>80 ms</strong>, 在Reverse Integer的Python3提交中击败了<strong>52.68%</strong> 的用户</p><p>另一种方法，其实我也想到了，但我觉得不至于用这种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;    </span><br><span class="line">        x = -int(str(x)[::-1][:-1]) if x &lt; 0 else int(str(x)[::-1])   # [:-1]相当于把负号去掉</span><br><span class="line">        x = 0 if abs(x) &gt; 0x7FFFFFFF else x</span><br><span class="line">        return x</span><br></pre></td></tr></table></figure></p><p>结果这种方法居然更快，这里是将数字转换成了字符串</p><p>执行用时: <strong>72 ms</strong>, 在Reverse Integer的Python3提交中击败了<strong>81.16%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;反转整数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_6 Z字形变换 medium</title>
    <link href="http://yoursite.com/2018/10/15/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_6/"/>
    <id>http://yoursite.com/2018/10/15/leetcode萌新练级_round1_6/</id>
    <published>2018-10-15T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>Z字形变换</strong></p><blockquote><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”<br>实现一个将字符串进行指定行数变换的函数:<br>string convert(string s, int numRows);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Longest Palindromic Substring</strong></p><blockquote><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:<br>string convert(string s, int numRows);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>代码还是写出来了，但是执行时间不够满意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        li = []</span><br><span class="line">        if numRows == 1:</span><br><span class="line">            return s</span><br><span class="line">        for i in range(numRows):</span><br><span class="line">            a = i</span><br><span class="line">            while a &lt; len(s):</span><br><span class="line">                if i == 0 or i == numRows - 1:</span><br><span class="line">                    li.append(s[a])</span><br><span class="line">                else:</span><br><span class="line">                    li.append(s[a])</span><br><span class="line">                    if a + 2*numRows - 2 - 2*i &lt; len(s):</span><br><span class="line">                        li.append(s[a + 2*numRows - 2 - 2*i])</span><br><span class="line">                a += 2 * numRows -2</span><br><span class="line">        return &apos;&apos;.join(li)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><p>执行用时: <strong>176 ms</strong>, 在ZigZag Conversion的Python3提交中击败了<strong>26.93%</strong> 的用户</p><p><a href="https://github.com/apachecn/awesome-algorithm/tree/master/docs/Leetcode_Solutions/Python" target="_blank" rel="noopener">网友的代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if numRows == 1 or numRows &gt;= len(s):</span><br><span class="line">            return s</span><br><span class="line">        res = [&apos;&apos;] * numRows</span><br><span class="line">        idx, step = 0, 1</span><br><span class="line">        for x in s:</span><br><span class="line">            res[idx] += x</span><br><span class="line">            if idx == 0:  ## 第一行，一直向下走</span><br><span class="line">                step = 1</span><br><span class="line">            elif idx == numRows - 1: ## 最后一行了，向上走</span><br><span class="line">                step = -1</span><br><span class="line">            idx += step</span><br><span class="line">        return &apos;&apos;.join(res)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p><p>这个代码总体和我写的差不多，只是直接使用while来解决了迭代问题</p><p>执行用时: <strong>92 ms</strong>, 在ZigZag Conversion的Python3提交中击败了<strong>99.51%</strong> 的用户</p><p>根据这个我又优化了自己的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        li = [&apos;&apos;] * numRows</span><br><span class="line">        if numRows == 1:</span><br><span class="line">            return s</span><br><span class="line">        for i in range(numRows):</span><br><span class="line">            a = i</span><br><span class="line">            while a &lt; len(s):</span><br><span class="line">                if i == 0 or i == numRows - 1:</span><br><span class="line">                    li[i] += s[a]</span><br><span class="line">                else:</span><br><span class="line">                    li[i] += s[a]</span><br><span class="line">                    if a + 2*numRows - 2 - 2*i &lt; len(s):</span><br><span class="line">                        li[i] += s[a + 2*numRows - 2 - 2*i]</span><br><span class="line">                a += 2 * numRows -2</span><br><span class="line">        return &apos;&apos;.join(li)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p><p>执行用时: <strong>140 ms</strong>, 在ZigZag Conversion的Python3提交中击败了<strong>60.43%</strong> 的用户</p><p>快了30ms，但还是不够快，果然还是网友的代码比较快→_→</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Z字形变换&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将字符串 “PAYPALISHIRING” 以Z字形排
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_3 无重复字符的最长子串 medium</title>
    <link href="http://yoursite.com/2018/10/12/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_3/"/>
    <id>http://yoursite.com/2018/10/12/leetcode萌新练级_round1_3/</id>
    <published>2018-10-12T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>无重复字符的最长子串</strong></p><blockquote><p>给定一个字符串，找出不含有重复字符的最长子串的长度。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3。</span><br></pre></td></tr></table></figure></p></blockquote><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 无重复字符的最长子串是 &quot;b&quot;，其长度为 1。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 无重复字符的最长子串是 &quot;wke&quot;，其长度为 3。</span><br><span class="line">     请注意，答案必须是一个子串，&quot;pwke&quot; 是一个子序列 而不是子串。</span><br></pre></td></tr></table></figure></p><p><strong>Longest Substring Without Repeating Characters</strong></p><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure></p></blockquote><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题没通过，986/987个通过了测试用例，挂在最后一个执行巨长的测试用例上了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~ abcd……</span><br></pre></td></tr></table></figure></p><p>失败原因是：<strong>超出时间限制</strong></p><p>前几次提交的错误中，包含了</p><ul><li>未考虑””空值情况</li><li>未考虑最长非重复字符串在最后的情况</li></ul><p>先贴一下自己失败的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        len_li = []</span><br><span class="line">        if not len(s):</span><br><span class="line">            return 0</span><br><span class="line">        for index_i,v_i in enumerate(s):</span><br><span class="line">            li = []</span><br><span class="line">            for index_j,v_j in enumerate(s[index_i:]):</span><br><span class="line">                if v_j not in li:</span><br><span class="line">                    li.append(v_j)</span><br><span class="line">                else:</span><br><span class="line">                    len_li.append(len(li))</span><br><span class="line">                    break</span><br><span class="line">                if index_j + 1 == len(s[index_i:]):</span><br><span class="line">                    len_li.append(len(li))</span><br><span class="line">        return max(len_li)</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(n^n)$</p><p>吐血了，刚开始刷LeetCode，<a href="https://github.com/kamyu104/LeetCode/tree/master/Python" target="_blank" rel="noopener">网友的代码</a>就被和谐了，重新找答案<a href="https://github.com/apachecn/awesome-algorithm/tree/master/docs/Leetcode_Solutions/Python" target="_blank" rel="noopener">另一个网友的代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        l, start, n = 0, 0, len(s)</span><br><span class="line">        maps = &#123;&#125;</span><br><span class="line">        for i in range(n):</span><br><span class="line">            start = max(start, maps.get(s[i], -1)+1)</span><br><span class="line">            l = max(l, i - start+1)</span><br><span class="line">            maps[s[i]] = i</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><blockquote><p>解题思路：<br>使用一个hashmap，将每一个已经阅读过的字符作为键，而它的值就是它在原字符串中的index，如果我们现在的字符不在hashmap里面我们就把它加进hashmap中去，因此，只要目前的这个字符在该hashmap中的值大于等于了这一轮字符串的首字符，就说明它已经出现过了，我们就将首字符的index加1，即从后一位又重新开始读，然后比较目前的子串长度与之前的最大长度，取大者。</p></blockquote><p>这个方法，真的很妙……读了好一会才看懂</p><p>执行用时: <strong>116 ms</strong>, 在Longest Substring Without Repeating Characters的Python3提交中击败了<strong>82.28%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;无重复字符的最长子串&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，找出不含有重复字符的最长子串
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_2 两数相加 medium</title>
    <link href="http://yoursite.com/2018/10/11/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_2/"/>
    <id>http://yoursite.com/2018/10/11/leetcode萌新练级_round1_2/</id>
    <published>2018-10-11T05:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>两数相加</strong></p><blockquote><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><p><strong>Add Two Numbers</strong></p><blockquote><p>You are given two <strong>non-empty</strong> linked lists representing two <strong>non-negative</strong> integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example:<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这一题个人感觉主要考察的是对<strong>链表</strong>的理解</p><p>链表平时用不到，学了也忘了，偷瞄了一下答案怎么用，然后写出了代码<br>自己编写的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1, l2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        new_li = ListNode(0)</span><br><span class="line"></span><br><span class="line">        alg_li, divisor = new_li, 0</span><br><span class="line">        while l1 or l2:</span><br><span class="line">            alg_val = divisor</span><br><span class="line">            if l1:</span><br><span class="line">                alg_val += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                alg_val += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            remainder = alg_val % 10 # 余数 1-9</span><br><span class="line">            divisor = int(alg_val / 10) # 除数 0-1</span><br><span class="line">            alg_li.next = ListNode(remainder)</span><br><span class="line">            alg_li = alg_li.next</span><br><span class="line">        if divisor == 1:</span><br><span class="line">            alg_li.next = ListNode(1)</span><br><span class="line">        return new_li.next</span><br></pre></td></tr></table></figure></p><p>通过了所有测试用例</p><p>执行用时: <strong>180 ms</strong>, 在Add Two Numbers的Python3提交中击败了<strong>38.16%</strong> 的用户</p><p>时间复杂度：$O(max(m,n))$ m,n是l1,l2的长度</p><p>空间复杂度：$O(max(m,n))$</p><p>几次提交错误的原因，包括了没有考虑俩列长度不等，将表头也带入了。<br>这个代码时间复杂度和空间复杂度没什么大的差别，主要是初等数学的掌握</p><p>用了<a href="https://github.com/kamyu104/LeetCode/tree/master/Python" target="_blank" rel="noopener">网友的代码</a>，主要区别是他使用了divmod函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dummy = ListNode(0)</span><br><span class="line">        current, carry = dummy, 0</span><br><span class="line"></span><br><span class="line">        while l1 or l2:</span><br><span class="line">            val = carry</span><br><span class="line">            if l1:</span><br><span class="line">                val += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                val += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            carry, val = divmod(val, 10)</span><br><span class="line">            current.next = ListNode(val)</span><br><span class="line">            current = current.next</span><br><span class="line"></span><br><span class="line">        if carry == 1:</span><br><span class="line">            current.next = ListNode(1)</span><br><span class="line"></span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(max(m,n))$</p><p>空间复杂度：$O(max(m,n))$</p><p>执行用时: <strong>156 ms</strong>, 在Add Two Numbers的Python3提交中击败了<strong>79.84%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;两数相加&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个非空链表来表示两个非负整数。位数按照逆序方式存储
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode萌新练级_round1_1 两数之和 easy</title>
    <link href="http://yoursite.com/2018/10/10/leetcode%E8%90%8C%E6%96%B0%E7%BB%83%E7%BA%A7_round1_1/"/>
    <id>http://yoursite.com/2018/10/10/leetcode萌新练级_round1_1/</id>
    <published>2018-10-10T01:00:00.000Z</published>
    <updated>2019-02-27T01:36:28.128Z</updated>
    
    <content type="html"><![CDATA[<p>刷算法题需要注意的地方：</p><ul><li>考虑时间复杂度</li><li>考虑空间复杂度</li><li>考虑极限情况、普通情况、大量数据情况</li></ul><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>两数之和</strong></p><blockquote><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><p><strong>Two Sum</strong></p><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>自己编写的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for index, value in enumerate(nums):</span><br><span class="line">            for index_1, value1 in enumerate(nums[index+1:]):</span><br><span class="line">                if value + value1 == target:</span><br><span class="line">                    return [index,index_1+index+1]</span><br></pre></td></tr></table></figure></p><p>通过了所有测试用例</p><p>执行用时: <strong>6476 ms</strong>, 在Two Sum的Python3提交中击败了 <strong>25.16%</strong> 的用户</p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(1)$</p><p>想来是因为用了2次遍历导致时间复杂度过高，看了下官方的解释，果然用的是暴力解决法_(:зゝ∠)_哈哈(干笑</p><p>参考了<a href="https://github.com/kamyu104/LeetCode/tree/master/Python" target="_blank" rel="noopener">网友的代码</a>，将时间复杂度降低到了$O(n)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        one_dict = &#123;&#125;</span><br><span class="line">        for index, value in enumerate(nums):</span><br><span class="line">            if target - value in one_dict:</span><br><span class="line">                return [one_dict[target-value],index]</span><br><span class="line">            one_dict[value] = index</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><p>执行用时: <strong>56 ms</strong>, 在Two Sum的Python3提交中击败了 <strong>70.35%</strong> 的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刷算法题需要注意的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑时间复杂度&lt;/li&gt;
&lt;li&gt;考虑空间复杂度&lt;/li&gt;
&lt;li&gt;考虑极限情况、普通情况、大量数据情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>markdown学习笔记</title>
    <link href="http://yoursite.com/2018/08/23/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/08/23/markdown学习笔记/</id>
    <published>2018-08-23T01:21:01.000Z</published>
    <updated>2019-02-27T01:36:28.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-公式"><a href="#一、-公式" class="headerlink" title="一、 公式"></a>一、 公式</h3><h4 id="1-显示于行内：-color-blue-f-x-x"><a href="#1-显示于行内：-color-blue-f-x-x" class="headerlink" title="1. 显示于行内： $\color {blue} {f(x)=x} $"></a>1. 显示于行内： $\color {blue} {f(x)=x} $</h4><p><code>$ f(x)=x $</code></p><h4 id="2-独立显示一行："><a href="#2-独立显示一行：" class="headerlink" title="2. 独立显示一行："></a>2. 独立显示一行：</h4><p><code>$$ s=\sum_1^n{n_i} $$</code></p><font color="#0000ff">$$ s=\sum_1^n{n_i} $$</font><h4 id="3-角标"><a href="#3-角标" class="headerlink" title="3. 角标"></a>3. 角标</h4><ul><li><strong>上标：</strong><font color="#0000ff">$ x^2 $</font><br><code>$ x^2 $</code></li><li><strong>下标：</strong><font color="#0000ff">$ x_i $</font><br><code>$ x_i $</code></li><li><strong>上下左右标：</strong><font color="#0000ff">$ \sideset{^1_2}{^3_4}\bigotimes $</font><br><code>$ \sideset{^1_2}{^3_4}\bigotimes $</code></li></ul><h4 id="4-下划线、上划线"><a href="#4-下划线、上划线" class="headerlink" title="4.下划线、上划线"></a>4.下划线、上划线</h4><ul><li><strong>上划线命令：</strong> <code>\overline{公式}</code></li><li><strong>下划线命令：</strong> <code>\underline{公式}</code><br><font color="#0000ff">$\overline{\overline{a^2}+\underline{ab}+\bar{a}^3}$</font> <code>$\overline{\overline{a^2}+\underline{ab}+\bar{a}^3}$</code></li><li><strong>上花括弧命令：</strong> <code>\overbrace{公式}{说明}</code></li><li><strong>下花括弧命令：</strong> <code>\underbrace{公式}_{说明}</code><br><code>$ \underbrace{a+\overbrace{b+\dots+b}^{m个}}_{20个} $</code><font color="#0000ff">$$ \underbrace{a+\overbrace{b+\dots+b}^{m个}}_{20个} $$</font></li></ul><h4 id="5-括号："><a href="#5-括号：" class="headerlink" title="5. 括号："></a>5. 括号：</h4><ul><li><p><strong>小括号与方括号</strong>:原始的就好</p></li><li><p><strong>大括号:</strong> <font color="#0000ff">$ \lbrace a+x \rbrace $</font><br><code>$ \lbrace a+x \rbrace $</code></p></li><li><p><strong>尖括号:</strong><font color="#0000ff">$ \langle x \rangle $</font><br><code>$ \langle x \rangle $</code></p></li><li><p><strong>上取整: </strong><font color="#0000ff">$ \lceil \frac{x}{2} \rceil $</font><br><code>$ \lceil \frac{x}{2} \rceil $</code></p></li><li><p><strong>下取整: </strong><font color="#0000ff">$ \lfloor x \rfloor $</font><br><code>$ \lfloor x \rfloor $</code></p></li><li><p><strong>注意：</strong>原始括号不会缩放,如 <code>$$ \lbrace \sum_{i=0}^{n}i^{2}=\frac{2a}{x^2+1} \rbrace $$</code></p><font color="#0000ff">$$ \lbrace \sum_{i=0}^{n}i^{2}=\frac{2a}{x^2+1} \rbrace $$</font><br>需要加入 \left \right   <code>$$ \left\lbrace \sum_{i=0}^{n}i^{2}=\frac{2a}{x^2+1} \right\rbrace $$</code><br><font color="#0000ff">$$  \left\lbrace \sum_{i=0}^{n}i^{2}=\frac{2a}{x^2+1} \right\rbrace $$</font></li></ul><h4 id="6-求和与积分："><a href="#6-求和与积分：" class="headerlink" title="6.求和与积分："></a>6.求和与积分：</h4><ul><li><p><strong>\sum 求和</strong>，<code>$$ \sum_i^n $$</code>下标表示求和下限，上标表示求和上限</p><font color="#0000ff">$$ \sum_i^n $$</font></li><li><p><strong>\int 积分</strong>，<code>$\$ \int_{1}^{\infty} $$</code>下标表示积分下限，上标表示积分上限</p><font color="#0000ff">$$ \int_{1}^{\infty} $$</font></li><li><p><strong>\prod 求积</strong>，<code>$$ \prod_{1}^{n} $$</code></p><font color="#0000ff">$$ \prod_{1}^{n} $$</font></li><li><p><strong>\bigcup 求并集</strong>，<code>$$ \bigcup_{1}^{n} $$</code></p><font color="#0000ff">$$ \bigcup_{1}^{n} $$</font></li><li><p><strong>\iint 双重积分</strong>，<code>$$ \iint_{1}^{n} $$</code></p><font color="#0000ff">$$ \iint_{1}^{n} $$</font></li><li><p><strong>改变上下限位置的命令：</strong> \limits(强制上下限在上下侧) 和 \nolimits(强制上下限在左右侧)<br><font color="#0000ff">$\sum\limits_{k=1}^n$</font> <code>$\sum\limits_{k=1}^n$</code><br><font color="#0000ff">$\sum\nolimits_{k=1}^n$</font> <code>$\sum\nolimits_{k=1}^n$</code></p></li></ul><h4 id="7-分式与根式"><a href="#7-分式与根式" class="headerlink" title="7.分式与根式"></a>7.分式与根式</h4><ul><li><p><strong>分式：</strong><code>$$ \frac ab $$</code></p><font color="#0000ff">$$ \frac ab $$</font><br><code>$$ \frac{1}{2} $$</code><br><font color="#0000ff">$$ \frac{1}{2} $$</font><br><code>$$ {a+1 \over b+1} $$</code><br><font color="#0000ff">$$ {a+1 \over b+1} $$</font><br><strong>连分式：</strong> <code>$$ x_0+\frac{1}{x_1+\frac{1}{x_2+\frac{1}{x_3+\frac{1}{x_4}}}} $$</code><br><font color="#0000ff">$$ x_0+\frac{1}{x_1+\frac{1}{x_2+\frac{1}{x_3+\frac{1}{x_4}}}}$$</font></li><li><p><strong>根式：</strong><code>$$ \sqrt[x+1]{x^2} $$</code><br><font color="#0000ff">$$ \sqrt[x+1]{x^2} $$</font><br>被开方表达式字符高度不一致时，根号上面的横线可能不是在同一条直线上；为了使横线在同一条直线上，可以在被开方表达式插入一个只有高度没有宽度的数学支柱\mathstut<br><font color="#0000ff">$\sqrt{a}+\sqrt{b}+\sqrt{c}$</font> <code>$\sqrt{a}+\sqrt{b}+\sqrt{c}</code><br><font color="#0000ff">$\sqrt{\mathstrut a}+\sqrt{\mathstrut b}+\sqrt{\mathstrut c}$</font> <code>$\sqrt{\mathstrut a}+\sqrt{\mathstrut b}+\sqrt{\mathstrut c}$</code></p></li></ul><h4 id="8-集合"><a href="#8-集合" class="headerlink" title="8. 集合"></a>8. 集合</h4><ul><li><strong>大括号：</strong><br><font color="#0000ff">${…}$</font> <code>$\{ ...\}$</code></li><li><strong>属于：</strong><br><font color="#0000ff">$ \in $</font> <code>$\in$</code></li><li><strong>不属于：</strong><br><font color="#0000ff">$\not\in$</font> <code>$\not\in$</code></li><li><strong>A包含于B：</strong><br><font color="#0000ff">$A\subset B$</font> <code>$A\subset B$</code></li><li><strong>A真包含于B：</strong><br><font color="#0000ff">$A \subsetneqq B$</font> <code>$A \subsetneqq B$</code></li><li><strong>A包含B：</strong><br><font color="#0000ff">$A \supset B$</font> <code>$A \supset B$</code></li><li><strong>A真包含B：</strong><br><font color="#0000ff">$A \supsetneqq B$</font> <code>$A \supsetneqq B$</code></li><li><strong>不包含于：</strong><br><font color="#0000ff">$A \not \subset B$</font> <code>$A \not \subset B$</code></li><li><strong>交集：</strong><br><font color="#0000ff">$A \cap B$</font> <code>$A \cap B$</code></li><li><strong>并集：</strong><br><font color="#0000ff">$A \cup B$</font> <code>$A \cup B$</code></li><li><strong>闭包：</strong><br><font color="#0000ff">$\overline{A}$</font> <code>$\overline{A}$</code></li><li><strong>A减去B：</strong><br><font color="#0000ff">$A\setminus B$</font> <code>$A\setminus B$</code></li><li><strong>实数集合：</strong><br><font color="#0000ff">$\mathbb{R}$</font> <code>$\mathbb{R}$</code></li><li><strong>空集：</strong><br><font color="#0000ff">$\emptyset$</font> <code>$\emptyset$</code></li></ul><h4 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9.运算符"></a>9.运算符</h4><ul><li><p><strong>乘：</strong><br><font color="#0000ff">$ x \times y $</font><code>$ x \times y $</code><br><font color="#0000ff">$ x \cdot y $</font><code>$ x \cdot y $</code><br><font color="#0000ff">$ x \ast y $</font><code>$ x \ast y $</code></p></li><li><p><strong>除：</strong><br><font color="#0000ff">$ x \div y $</font><code>$ x \div y $</code></p></li><li><p><strong>加减：</strong><br><font color="#0000ff">$ x \pm y $</font><code>$ x \pm y $</code></p></li><li><p><strong>减加：</strong><br><font color="#0000ff">$ x \mp y $</font><code>$ x \mp y $</code></p></li><li><p><strong>小于等于：</strong><br><font color="#0000ff">$ x \leq y $</font><code>$ x \leq y $</code></p></li><li><p><strong>大于等于：</strong><br><font color="#0000ff">$ x \geq y $</font><code>$ x \geq y $</code></p></li><li><p><strong>不大于等于：</strong><br><font color="#0000ff">$ x \ngeq y $</font><code>$ x \ngeq y $</code></p></li><li><p><strong>不大于等于：</strong><br><font color="#0000ff">$ x \not\geq y $</font><code>$ x \not\geq y $</code></p></li><li><p><strong>不等于：</strong><br><font color="#0000ff">$ x \neq y $</font><code>$ x \neq y $</code></p></li><li><p><strong>约等于：</strong><br><font color="#0000ff">$ x \approx y $</font><code>$ x \approx y $</code></p></li><li><p><strong>恒等于：</strong><br><font color="#0000ff">$ x \equiv y $</font><code>$ x \equiv y $</code></p></li><li><p><strong>定义运算符：</strong><br><font color="#0000ff">$ x \bigodot y=x+y^2 $</font><code>$ x \bigodot y=x+y^2 $</code></p></li><li><p><strong>定义运算符：</strong><br><font color="#0000ff">$ x \bigotimes y=x+y^2 $</font><code>$ x \bigotimes y=x+y^2 $</code></p></li></ul><h4 id="10-带帽符号"><a href="#10-带帽符号" class="headerlink" title="10.带帽符号"></a>10.带帽符号</h4><ul><li><font color="#0000ff">$ \hat{xy} $</font> <code>$ \hat{xy} $</code></li><li><font color="#0000ff">$ \widehat{xyz} $</font> <code>$ \widehat{xyz} $</code></li><li><font color="#0000ff">$ \tilde{xy} $</font> <code>$ \tilde{xy} $</code></li><li><font color="#0000ff">$ \widetilde{xyz} $</font> <code>$ \widetilde{xyz} $</code></li><li><font color="#0000ff">$ \check{x} $</font> <code>$ \check{x} $</code></li><li><font color="#0000ff">$ \breve{y} $</font> <code>$ \breve{y} $</code></li><li><font color="#0000ff">$ \grave{x} $</font> <code>$ \grave{x} $</code></li><li><font color="#0000ff">$ \acute{y} $</font> <code>$ \acute{y} $</code></li></ul><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul><li><p><strong>黑板粗体字：</strong><br><font color="#0000ff">$ \Bbb SAMPLE$</font><code>$ \Bbb 字母$</code></p></li><li><p><strong>字号：</strong><br><font color="#0000ff">$\tiny 萌萌哒$</font><code>$\tiny 萌萌哒$</code><br><font color="#0000ff">$\scriptsize 萌萌哒$</font><code>$\scriptsize 萌萌哒$</code><br><font color="#0000ff">$\small 萌萌哒$</font><code>$\small 萌萌哒$</code><br><font color="#0000ff">$\normalsize 萌萌哒(正常)$</font><code>$\normalsize 萌萌哒(正常)$</code><br><font color="#0000ff">$\large 萌萌哒$</font><code>$\large 萌萌哒$</code><br><font color="#0000ff">$\Large 萌萌哒$</font><code>$\Large 萌萌哒$</code><br><font color="#0000ff">$\huge 萌萌哒$</font><code>$\huge 萌萌哒$</code><br><font color="#0000ff">$\Huge 萌萌哒$</font><code>$\Huge 萌萌哒$</code></p></li><li><p><strong>占位宽度：</strong><br><font color="#0000ff">$ a \qquad b $</font><code>$ a \qquad b $</code> 两个m的宽度<br><font color="#0000ff">$ a \quad b $</font><code>$ a \quad b $</code> 一个m的宽度<br><font color="#0000ff">$ a\ b $</font><code>$ a\ b $</code> 1/3m宽度<br><font color="#0000ff">$ a\;b $</font><code>$ a\;b $</code> 2/7m宽度<br><font color="#0000ff">$ a\,b $</font><code>$ a\,b $</code> 1/6m宽度<br><font color="#0000ff">$ ab $</font><code>$ ab $</code> 没有空格<br><font color="#0000ff">$ a!b $</font><code>$ a\!b $</code> 紧贴，缩进1/6m宽度</p></li></ul><p>参考资料：<br><a href="https://www.zybuluo.com/codeep/note/163962#cmd-markdown-%E5%85%AC%E5%BC%8F%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">https://www.zybuluo.com/codeep/note/163962#cmd-markdown-%E5%85%AC%E5%BC%8F%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C</a><br><a href="https://blog.csdn.net/yzr1183739890/article/details/64130912" target="_blank" rel="noopener">https://blog.csdn.net/yzr1183739890/article/details/64130912</a><br><a href="https://blog.csdn.net/garfielder007/article/details/51646604" target="_blank" rel="noopener">https://blog.csdn.net/garfielder007/article/details/51646604</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、-公式&quot;&gt;&lt;a href=&quot;#一、-公式&quot; class=&quot;headerlink&quot; title=&quot;一、 公式&quot;&gt;&lt;/a&gt;一、 公式&lt;/h3&gt;&lt;h4 id=&quot;1-显示于行内：-color-blue-f-x-x&quot;&gt;&lt;a href=&quot;#1-显示于行内：-color-b
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>多台电脑更新hexo博客</title>
    <link href="http://yoursite.com/2018/07/23/%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/07/23/多台电脑更新博客/</id>
    <published>2018-07-23T01:18:01.000Z</published>
    <updated>2019-02-27T01:36:28.146Z</updated>
    
    <content type="html"><![CDATA[<p>在自己的电脑上使用了github的博客hexo，用的很顺利。</p><p>后来业务需要又多了一台电脑办公，想要更新博客就很困难了<em>(:з」∠)</em></p><p>在网上找了一些解决方案：<a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="noopener">https://www.jianshu.com/p/0b1fccce74e0</a></p><hr><h3 id="根据解决方案自己进行的操作及原理"><a href="#根据解决方案自己进行的操作及原理" class="headerlink" title="根据解决方案自己进行的操作及原理"></a>根据解决方案自己进行的操作及原理</h3><p>这个同步其实比较好实现，但是因为什么分支，不同电脑，不同文件夹，又是push又是pull，导致我花了好久才看到@^@，所以总结一下。</p><p>A电脑是我们平时写博客用的电脑。</p><p>B电脑是我们想要在上面写博客的新电脑。</p><p>首先要按照解决方案中(第二章1、2节)的方式为github项目创建分支并设置为默认分支，我的分支名字叫bachelor(和master对比，皮一下)，将分支clone到A电脑上，新建文件夹如/Users/xiaomi/new，不与已存在的本地博客/Users/xiaomi/old冲突。</p><p>(第二章第3节)再将原来的本地博客文件夹old中的配置文件，包括根目录下的_config.yml和source、tags、themes拷贝到new的根目录下。要将theme目录下的.git文件(如果有)删掉，.git隐藏文件。</p><p>(第二章第4节)将new文件夹的更新提交到github。</p><p>(第三章)切换到新电脑B，将bachelor分支clone到本地/Users/xiaomi_office/new。在B电脑上安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>安装好后cd 到new文件夹中，执行npm install，此时会在new文件夹中生成一个node_modules文件夹，还有package_lock.json文件。将这俩个文件添加到.gitignore中，也就是默认不提交到github上。</p><p>(第四章)此时在终端使用hexo的操作命令，就可以在本地预览博客和提交博客了。使用hexo generate的时候会在new文件夹中生成新的html文件，使用hexo deploy时，会默认将html文件提交到github的master分支中，所以我们还需要手动push整个项目new文件夹的更新到bachlor分支去。</p><p>所以每次对博客进行更新之后一定要push代码到github，下次换电脑就可以直接pull下来获取更新了。</p><hr><h3 id="每次更新需要的操作"><a href="#每次更新需要的操作" class="headerlink" title="每次更新需要的操作"></a>每次更新需要的操作</h3><h5 id="同步github分支更新"><a href="#同步github分支更新" class="headerlink" title="同步github分支更新"></a>同步github分支更新</h5><p>首先通过fork将github上副分支的更新pull下来，保证与github是同一版</p><h5 id="向github提交新博客"><a href="#向github提交新博客" class="headerlink" title="向github提交新博客"></a>向github提交新博客</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 自己电脑</span><br><span class="line">cd /Users/xiaomi/Documents/Python/gitproject/otakurice.github.io</span><br><span class="line"># 业务电脑</span><br><span class="line">cd /Users/xiaomi/Documents/xiaomi/github_blog</span><br></pre></td></tr></table></figure><p>后续操作与之前同步博客一样</p><ul><li><p>启动本地服务器<br>可通过：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 在本地预览博客效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></li><li><p>清除缓存(可选操作)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure></li><li><p>生成博客文章静态页面<br>md文章编辑成功后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/xiaomi/Documents/Python/blog</span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></li><li><p>将文章部署至github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></li></ul><h5 id="向分支push更新"><a href="#向分支push更新" class="headerlink" title="向分支push更新"></a>向分支push更新</h5><p>通过hexo deploy提交的博客，实际上是将生成html文件提交到了master分支。</p><p>我们要把博客里的配置文件与源文件都提交到副分支中，以保证副分支是最新的。</p><p>使用fork将更新后的博客push到副分支。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在自己的电脑上使用了github的博客hexo，用的很顺利。&lt;/p&gt;
&lt;p&gt;后来业务需要又多了一台电脑办公，想要更新博客就很困难了&lt;em&gt;(:з」∠)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在网上找了一些解决方案：&lt;a href=&quot;https://www.jianshu.com/p/0b
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="命令合辑" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E5%90%88%E8%BE%91/"/>
    
  </entry>
  
</feed>
